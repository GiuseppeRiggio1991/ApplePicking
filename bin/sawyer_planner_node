#!/usr/bin/env python

import rospy

from sawyer_planner import sawyer_planner_node
import sys
import random
import numpy
import openravepy
import pyquaternion

LOGGING = True
# sequencing_metrics = ['hybrid', 'euclidean', 'fredsmp']
# sequencing_metrics = ['fredsmp', 'euclidean']
sequencing_metrics = ['euclidean']
# sequencing_metrics = ['fredsmp']
num_targets = 1
num_experiments = 1

def transform_target_start(target, planner):
    q = pyquaternion.Quaternion(0.5, -0.5, 0.5, -0.5)
    goal_off = target - numpy.array([planner.starting_position_offset, 0.0, 0.0])
    # compute camera transform
    T_EE = numpy.zeros((4, 4))
    T_EE[:3, :3] = q.rotation_matrix
    T_EE[:3, 3] = goal_off.transpose()
    T_EE[3, 3] = 1.0

    T_C = numpy.dot(T_EE, numpy.linalg.inv(planner.T_G2EE))
    return T_C

def transform_target_offset(target, planner):
    q = pyquaternion.Quaternion(0.5, -0.5, 0.5, -0.5)
    goal_off = target - numpy.array([planner.go_to_goal_offset, 0.0, 0.0])
    # compute camera transform
    T_EE = numpy.zeros((4, 4))
    T_EE[:3, :3] = q.rotation_matrix
    T_EE[:3, 3] = goal_off.transpose()
    T_EE[3, 3] = 1.0

    T_C = numpy.dot(T_EE, numpy.linalg.inv(planner.T_G2EE))
    return T_C

def gen_goal_and_noise_arrays(planner, num_targets=8):
    # random.seed(time.time())
    # numpy.random.seed(time.time())
    goal_array = []
    noise_array = []
    solutions = []
    solutions_offset = []
    for i in range(num_targets):  # ensure target is reachable
        while len(solutions) == 0:
            rand_x = random.uniform(0.085, 0.095)
            rand_y = random.uniform(-0.35, 0.35)
            rand_z = random.uniform(0.2, 0.7)
            target = [rand_x, rand_y, rand_z]
            T_robot = transform_target_start(target, planner)
            pose_msg = planner.pose_to_ros_msg(openravepy.poseFromMatrix(T_robot))
            resp = planner.find_ik_solutions_srv(pose_msg, False)
            solutions = resp.solutions
            print len(solutions)
            # solutions = planner.ikmodel.manip.FindIKSolutions(
            #             T_robot,
            #             openravepy.IkFilterOptions.CheckEnvCollisions)
        goal_array.append(target)

        while len(solutions_offset) == 0:  # ensure noisy target is reachable
            # x_noise = numpy.random.normal(0.1, 0.05)
            # y_noise = numpy.random.normal(0.0, 0.05)
            # z_noise = numpy.random.normal(0.0, 0.05)
            x_noise = numpy.random.normal(0.01, 0.01)
            y_noise = numpy.random.normal(0.0, 0.1)
            z_noise = numpy.random.normal(0.0, 0.1)
            noisy_target = numpy.asarray(goal_array[-1] + numpy.asarray([x_noise, y_noise, z_noise]))
            # print noisy_target
            T_robot_offset = transform_target_offset(noisy_target, planner)
            pose_msg = planner.pose_to_ros_msg(openravepy.poseFromMatrix(T_robot_offset))
            resp = planner.find_ik_solutions_srv(pose_msg, True)
            solutions_offset = resp.solutions
            print len(solutions_offset)
            # solutions_offset = planner.ikmodel.manip.FindIKSolutions(
            #             T_robot_offset,
            #             openravepy.IkFilterOptions.CheckEnvCollisions)
        noise_array.append([x_noise, y_noise, z_noise])
        solutions_offset = []
        solutions = []
    noise_array = numpy.asarray(noise_array)

    # add Gaussian noise
    # x_noise = numpy.random.normal(0.1, 0.075, len(goal_array))
    # y_noise = numpy.random.normal(0.0, 0.075, len(goal_array))
    # z_noise = numpy.random.normal(0.0, 0.075, len(goal_array))
    # noise_array = numpy.vstack((x_noise, y_noise, z_noise)).transpose()
    return goal_array, noise_array


if __name__ == "__main__":

    rospy.init_node('sawyer_planner')
    rate = rospy.Rate(1000)
    # sim = False
    # if len(sys.argv) > 1:
    #     if sys.argv[1] == 'sim':
    #         sim = True
    if rospy.has_param("sim"):
        sim = rospy.get_param("sim")
    else:
        sim = False

    if rospy.has_param('/robot_name'):
        print "rospy.get_param: "
        print rospy.get_param("/robot_name")
        robot_name = rospy.get_param("/robot_name")
    else:
        print "no robot_name param, using sawyer "
        robot_name = "sawyer"

    last_joints = []

    still_running = True
    if LOGGING and sim:
        planner = sawyer_planner_node.SawyerPlanner('euclidean', sim, robot_name=robot_name)
        home_pose = [
            [-0.99, 0.04, 0.13, 0.2],
            [-0.13, -0.30, -0.94, -0.4],
            [0.00, -0.95, 0.30, 0.85],
            [0.00, 0.00, 0.00, 1.00]
        ]
        # home_pose_solutions = self.or_env.ikmodel.manip.FindIKSolutions(
        #     home_pose, openravepy.IkFilterOptions.CheckEnvCollisions
        # )
        # T_robot = transform_target_start(target, planner)
        pose_msg = planner.pose_to_ros_msg(openravepy.poseFromMatrix(home_pose))
        resp = planner.find_ik_solutions_srv(pose_msg, False)
        solutions = resp.solutions
        print(solutions[0])
        for i in range(num_experiments):
            rospy.loginfo("STARTING EXPERIMENT " + str(i))
            rand_int = random.randint(0, len(solutions) - 1)
            last_joints = solutions[rand_int].position
            # goal_array, noise_array = gen_goal_and_noise_arrays(planner, num_targets)
            for metric in sequencing_metrics:
                rospy.loginfo("METRIC: " + metric)
                still_running = True
                # planner = sawyer_planner_node.SawyerPlanner(metric, sim, goal_array, noise_array, last_joints, robot_name=robot_name)
                planner = sawyer_planner_node.SawyerPlanner(metric, sim, [], [], last_joints, robot_name=robot_name)
                while still_running and not rospy.is_shutdown():
                    # print(planner.goal_array)
                    # planner.sequence_goals()
                    still_running = planner.update()

                    rate.sleep()
            # last_joints = planner.manipulator_joints
    else:
        metric = 'euclidean'
        planner = sawyer_planner_node.SawyerPlanner(metric, sim, robot_name=robot_name)
        while still_running and not rospy.is_shutdown():
            # print(planner.goal_array)
            # planner.sequence_goals()
            still_running = planner.update()

            rate.sleep()


    rospy.on_shutdown(planner.clean)
