#!/usr/bin/env python

import rospy

from sawyer_planner import sawyer_planner_node
import sys
import random
import numpy
import numpy as np
import openravepy
import pyquaternion
import cPickle
import math
import rospkg
import os
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Point
from pprint import pprint
from sawyer_planner.point_selector import PointSelector
from sawyer_planner.msg import PlannerGoal
from copy import deepcopy

LOGGING = True
# sequencing_metrics = ['hybrid', 'euclidean', 'fredsmp']
# sequencing_metrics = ['fredsmp', 'euclidean']
sequencing_metrics = ['euclidean']
# sequencing_metrics = ['fredsmp']
num_targets = 5
num_experiments = 1

def transform_target_start(target, planner):
    q = pyquaternion.Quaternion(0.5, -0.5, 0.5, -0.5)
    goal_off = target - numpy.array([0.25, 0.0, 0.0])
    # compute camera transform
    T_EE = numpy.zeros((4, 4))
    T_EE[:3, :3] = q.rotation_matrix
    T_EE[:3, 3] = goal_off.transpose()
    T_EE[3, 3] = 1.0

    T_C = numpy.dot(T_EE, numpy.linalg.inv(planner.T_G2EE))
    return T_C

def transform_target_offset(target, planner):
    q = pyquaternion.Quaternion(0.5, -0.5, 0.5, -0.5)
    goal_off = target - numpy.array([planner.go_to_goal_offset, 0.0, 0.0])
    # compute camera transform
    T_EE = numpy.zeros((4, 4))
    T_EE[:3, :3] = q.rotation_matrix
    T_EE[:3, 3] = goal_off.transpose()
    T_EE[3, 3] = 1.0

    T_C = numpy.dot(T_EE, numpy.linalg.inv(planner.T_G2EE))
    return T_C

def gen_goal_and_noise_arrays(planner, num_targets=1):
    # random.seed(time.time())
    # numpy.random.seed(time.time())
    goal_array = []
    orientation_array = []
    noise_array = []
    solutions = []
    solutions_offset = []
    for i in range(num_targets):  # ensure target is reachable
        while len(solutions) == 0:
            # rand_x = random.uniform(0.65, 0.75)
            # rand_y = random.uniform(-0.35, 0.35)
            rand_x = random.uniform(0.2, 0.75)
            rand_y = 1.15-rand_x
            rand_z = random.uniform(0.2, 0.7)

            # rand_x = random.uniform(0.5, 1.5)
            # rand_y = random.uniform(-0.3, 0.3)
            # rand_z = random.uniform(-0.3, 0.3)
            #
            target = np.array([rand_x, rand_y, rand_z])
            lookat = target * 1.2
            pose = openravepy.transformLookat(lookat, target, [0, 0, -1])
            # target = [0.5, 0.4, 0.5]
            # pose = openravepy.transformLookat([1.0, 0, 0.5], [0.5, 0.4, 0.5], [0, 0, -1])
            pose_msg = planner.pose_to_ros_msg(openravepy.poseFromMatrix(pose))
            resp = planner.find_ik_solutions_srv(pose_msg, False)
            solutions = resp.solutions
            print len(solutions)
            # solutions = planner.ikmodel.manip.FindIKSolutions(
            #             T_robot,
            #             openravepy.IkFilterOptions.CheckEnvCollisions)
        goal_array.append(target)

        # Add the orientation reference in; tries to make branch "tangent" to robot arm

        goal = np.array(target)
        # angle = math.atan2(goal[1], goal[0])
        # r = np.sqrt(goal[0] ** 2 + goal[1] ** 2)
        # rx, ry = r * math.cos(angle + 0.01), r * math.sin(angle + 0.01)  # Creates branch "tangent" to radius
        # rz = goal[2]
        #
        # ref_point = np.array([rx, ry, rz])
        # diff = ref_point - goal
        # diff = diff / np.sqrt((diff ** 2).sum())
        # # This is where the elevation difference comes in
        # diff[2] = random.choice([0.5, 10, -0.5, -10])

        diff = np.random.uniform(-0.5, 0.5, (3,))
        ref_point = goal + diff
        orientation_array.append(ref_point)

        x_noise = y_noise = z_noise = 0

        # while len(solutions_offset) == 0:  # ensure noisy target is reachable
        #     x_noise = numpy.random.normal(0.01, 0.01)
        #     y_noise = numpy.random.normal(0.0, 0.1)
        #     z_noise = numpy.random.normal(0.0, 0.1)
        #     noisy_target = numpy.asarray(goal_array[-1] + numpy.asarray([x_noise, y_noise, z_noise]))
        #     # print noisy_target
        #     T_robot_offset = transform_target_offset(noisy_target, planner)
        #     pose_msg = planner.pose_to_ros_msg(openravepy.poseFromMatrix(T_robot_offset))
        #     resp = planner.find_ik_solutions_srv(pose_msg, True)
        #     solutions_offset = resp.solutions
        #     print len(solutions_offset)
        #     # solutions_offset = planner.ikmodel.manip.FindIKSolutions(
        #     #             T_robot_offset,
        #     #             openravepy.IkFilterOptions.CheckEnvCollisions)
        noise_array.append([x_noise, y_noise, z_noise])
        solutions_offset = []
        solutions = []
    noise_array = numpy.asarray(noise_array)

    # Temp: Ignore noise array
    final_goals = []
    for goal, orientation in zip(goal_array, orientation_array):
        final_goal = PlannerGoal()
        final_goal.goal = Point(*goal)
        final_goal.orientation = Point(*orientation)
        final_goals.append(final_goal)

    return final_goals


if __name__ == "__main__":

    rospy.init_node('sawyer_planner')
    rate = rospy.Rate(1000)
    if rospy.has_param("sim"):
        sim = rospy.get_param("sim")
    else:
        sim = False

    # Load an existing configuration, or create a new one if it doesn't exist
    existing_config = {}
    file_path = ''
    if len(sys.argv) > 1:
        config_file_name = sys.argv[1].strip()

        rospack = rospkg.RosPack()
        config_dir = os.path.join(rospack.get_path('sawyer_planner'), 'configs')
        if not os.path.exists(config_dir):
            os.makedirs(config_dir)
        try:
            file_path = os.path.join(config_dir, config_file_name)
            with open(file_path, 'rb') as fh:
                existing_config = cPickle.load(fh)
                rospy.loginfo('Found existing config {}'.format(config_file_name))
                pprint(existing_config)
        except IOError:
            rospy.loginfo('Will create new config "{}" based on current arm configuration and goals'.format(config_file_name))

    goals = existing_config.get('goal', None)
    starting_joints = existing_config.get('starting_joints', None)

    robot_name = rospy.get_param('robot_name', 'sawyer')
    rospy.loginfo('Robot name: {}'.format(robot_name))

    # If the config doesn't exist, try to load it based off the parameters
    # Configs can be loaded in 3 ways: Randomly generated points, RGB segmentation, or picking using the RViz interface

    if not existing_config:

        use_camera = rospy.get_param('/use_camera', False)
        target_color = rospy.get_param('/target_color', False)

        dummy_planner = sawyer_planner_node.SawyerPlanner('euclidean', [], sim=sim, robot_name=robot_name)

        if use_camera:

            # If we don't have an RGB target but we're using the camera, we use the point selector in RViz
            # to select the points we want
            selector = PointSelector(rospy.get_param('base_frame'), rospy.get_param('global_camera_cloud'))
            selector.wait_for_inputs()
            goals = selector.goals

            del selector

        else:
            # Otherwise we just randomly select points
            goals = gen_goal_and_noise_arrays(dummy_planner, num_targets)
        del dummy_planner

        # If we passed in a name for this config, go ahead and save it
        if file_path:
            config_to_save = {
                'goal': goals,
                'starting_joints': rospy.wait_for_message('manipulator_joints', JointState).position
            }

            with open(file_path, 'wb') as fh:
                cPickle.dump(config_to_save, fh)
            rospy.loginfo('Saved start config {}'.format(config_file_name))


    # Run the planner loops

    still_running = True
    if sim:
        for i in range(num_experiments):
            rospy.loginfo("STARTING EXPERIMENT " + str(i))

            for metric in sequencing_metrics:
                rospy.loginfo("METRIC: " + metric)
                still_running = True
                planner = sawyer_planner_node.SawyerPlanner(metric, goals, sim=sim, starting_joints=starting_joints,
                                                            robot_name=robot_name)
                while still_running and not rospy.is_shutdown():
                    still_running = planner.update()
                    rate.sleep()

    else:
        metric = sequencing_metrics[0]

        planner = sawyer_planner_node.SawyerPlanner(metric, goals, sim=sim, robot_name=robot_name)
        if existing_config:

            planner.plan_to_joints(starting_joints)
            planner.initial_joints.position = starting_joints

        try:
            while still_running and not rospy.is_shutdown():
                # print(planner.goal_array)
                # planner.sequence_goals()
                still_running = planner.update()

                rate.sleep()
        finally:
            planner.stop_arm()
            planner.go_to_start()


    rospy.on_shutdown(planner.clean)
