#!/usr/bin/env python

import rospy

from sawyer_planner import sawyer_planner_node
import sys
import random
import numpy
import numpy as np
import openravepy
import pyquaternion
import cPickle
import math
import rospkg
import os
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Point
from pprint import pprint
from sawyer_planner.point_selector import PointSelector
from sawyer_planner.msg import PlannerGoal
from copy import deepcopy
import random
import time

LOGGING = True
# sequencing_metrics = ['hybrid', 'euclidean', 'fredsmp']
# sequencing_metrics = ['fredsmp', 'euclidean']
# sequencing_metrics = ['euclidean']
sequencing_metrics = ['fredsmp', 'euclidean']
num_targets = 5
num_experiments = 1

def transform_target_start(target, planner):
    q = pyquaternion.Quaternion(0.5, -0.5, 0.5, -0.5)
    goal_off = target - numpy.array([0.25, 0.0, 0.0])
    # compute camera transform
    T_EE = numpy.zeros((4, 4))
    T_EE[:3, :3] = q.rotation_matrix
    T_EE[:3, 3] = goal_off.transpose()
    T_EE[3, 3] = 1.0

    T_C = numpy.dot(T_EE, numpy.linalg.inv(planner.T_G2EE))
    return T_C

def transform_target_offset(target, planner):
    q = pyquaternion.Quaternion(0.5, -0.5, 0.5, -0.5)
    goal_off = target - numpy.array([planner.go_to_goal_offset, 0.0, 0.0])
    # compute camera transform
    T_EE = numpy.zeros((4, 4))
    T_EE[:3, :3] = q.rotation_matrix
    T_EE[:3, 3] = goal_off.transpose()
    T_EE[3, 3] = 1.0

    T_C = numpy.dot(T_EE, numpy.linalg.inv(planner.T_G2EE))
    return T_C

def gen_goal_and_noise_arrays(planner, num_targets=1):
    # random.seed(time.time())
    # numpy.random.seed(time.time())
    goal_array = []
    orientation_array = []
    noise_array = []
    solutions = []
    solutions_offset = []
    for i in range(num_targets):  # ensure target is reachable
        while len(solutions) == 0:
            # rand_x = random.uniform(0.65, 0.75)
            # rand_y = random.uniform(-0.35, 0.35)
            rand_x = random.uniform(0.2, 0.75)
            rand_y = 1.15-rand_x
            rand_z = random.uniform(0.2, 0.7)
            target = [rand_x, rand_y, rand_z]
            T_robot = transform_target_start(target, planner)
            pose_msg = planner.pose_to_ros_msg(openravepy.poseFromMatrix(T_robot))
            resp = planner.find_ik_solutions_srv(pose_msg, False)
            solutions = resp.solutions
            print len(solutions)
            # solutions = planner.ikmodel.manip.FindIKSolutions(
            #             T_robot,
            #             openravepy.IkFilterOptions.CheckEnvCollisions)
        goal_array.append(target)

        # Add the orientation reference in; tries to make branch "tangent" to robot arm

        goal = np.array(target)
        angle = math.atan2(goal[1], goal[0])
        r = np.sqrt(goal[0] ** 2 + goal[1] ** 2)
        rx, ry = r * math.cos(angle + 0.01), r * math.sin(angle + 0.01)  # Creates branch "tangent" to radius
        rz = goal[2]

        ref_point = np.array([rx, ry, rz])
        diff = ref_point - goal
        diff = diff / np.sqrt((diff ** 2).sum())
        # This is where the elevation difference comes in
        diff[2] = random.choice([0.5, 10, -0.5, -10])

        ref_point = goal + diff

        orientation_array.append(ref_point)

        while len(solutions_offset) == 0:  # ensure noisy target is reachable
            x_noise = numpy.random.normal(0.01, 0.01)
            y_noise = numpy.random.normal(0.0, 0.1)
            z_noise = numpy.random.normal(0.0, 0.1)
            noisy_target = numpy.asarray(goal_array[-1] + numpy.asarray([x_noise, y_noise, z_noise]))
            # print noisy_target
            T_robot_offset = transform_target_offset(noisy_target, planner)
            pose_msg = planner.pose_to_ros_msg(openravepy.poseFromMatrix(T_robot_offset))
            resp = planner.find_ik_solutions_srv(pose_msg, True)
            solutions_offset = resp.solutions
            print len(solutions_offset)
            # solutions_offset = planner.ikmodel.manip.FindIKSolutions(
            #             T_robot_offset,
            #             openravepy.IkFilterOptions.CheckEnvCollisions)
        noise_array.append([x_noise, y_noise, z_noise])
        solutions_offset = []
        solutions = []
    noise_array = numpy.asarray(noise_array)

    # Temp: Ignore noise array
    final_goals = []
    for goal, orientation in zip(goal_array, orientation_array):
        final_goal = PlannerGoal()
        final_goal.goal = Point(*goal)
        final_goal.orientation = Point(*orientation)
        final_goals.append(final_goal)

    return final_goals


if __name__ == "__main__":

    rospy.init_node('sawyer_planner')
    rate = rospy.Rate(1000)
    if rospy.has_param("sim"):
        sim = rospy.get_param("sim")
    else:
        sim = False

    # Load an existing configuration, or create a new one if it doesn't exist
    existing_config = {}
    file_path = ''
    config_file_name = None
    if len(sys.argv) > 1:
        config_file_name = sys.argv[1].strip()

        rospack = rospkg.RosPack()
        config_dir = os.path.join(rospack.get_path('sawyer_planner'), 'configs')
        if not os.path.exists(config_dir):
            os.makedirs(config_dir)
        try:
            file_path = os.path.join(config_dir, config_file_name)
            with open(file_path, 'rb') as fh:
                existing_config = cPickle.load(fh)
                rospy.loginfo('Found existing config {}'.format(config_file_name))
                pprint(existing_config)
        except IOError:
            rospy.loginfo('Will create new config "{}" based on current arm configuration and goals'.format(config_file_name))

    goals = existing_config.get('goal', None)
    starting_joints = existing_config.get('starting_joints', None)

    robot_name = rospy.get_param('robot_name', 'sawyer')
    rospy.loginfo('Robot name: {}'.format(robot_name))

    # If the config doesn't exist, try to load it based off the parameters
    # Configs can be loaded in 3 ways: Randomly generated points, RGB segmentation, or picking using the RViz interface

    if not existing_config:

        use_camera = rospy.get_param('/use_camera', False)
        target_color = rospy.get_param('/target_color', False)

        dummy_planner = sawyer_planner_node.SawyerPlanner('euclidean', [], sim=sim, robot_name=robot_name)

        if use_camera:
            if target_color:
                raise NotImplementedError('Segmenting off color is temporarily disabled')
                # # If we have an RGB target set, we're assumed to be color-based tracking (e.g. colored tape)
                # dummy_planner.rgb_segment_set_goal()
                # goal_array = dummy_planner.goal_array
                # orientation_array = dummy_planner.orientation_array
                # noise_array = dummy_planner.noise_array

            else:
                # If we don't have an RGB target but we're using the camera, we use the point selector in RViz
                # to select the points we want

                rospack = rospkg.RosPack()
                home_file_location = os.path.join(rospack.get_path('sawyer_planner'), 'include', 'home_position.pickle')

                home_joints = None

                # Kinda hacky, just for experimental purposes
                try:
                    with open(home_file_location, 'rb') as fh:
                        home_joints = cPickle.load(fh)
                    dummy_planner.plan_to_joints(home_joints.position)
                except IOError:
                    rospy.logwarn('No home position file found')
                num_targets = np.random.randint(5, 10) + 1      # Pick between 6 and 10 cut points

                cut_targets = sorted(np.random.choice(np.arange(18) + 1, num_targets, replace=False))
                msg = "Your lucky numbers of the day are:\n{}".format('\n'.join(['\t{}'.format(x) for x in cut_targets]))
                print(msg)

                selector = PointSelector('base_link', '/camera/depth_registered/points_z_filtered')
                selector.wait_for_inputs()
                goals = selector.goals

                del selector

                if home_joints is not None:
                    dummy_planner.plan_to_joints(home_joints.position)

        else:
            # Otherwise we just randomly select points
            goals = gen_goal_and_noise_arrays(dummy_planner, num_targets)

        dummy_planner.clean()
        del dummy_planner

        # If we passed in a name for this config, go ahead and save it
        if file_path:
            config_to_save = {
                'goal': goals,
                'starting_joints': rospy.wait_for_message('manipulator_joints', JointState).position
            }

            with open(file_path, 'wb') as fh:
                cPickle.dump(config_to_save, fh)
            rospy.loginfo('Saved start config {}'.format(config_file_name))


    # Run the planner loops
    still_running = True
    time_base = time.strftime("%Y%m%d-%H%M%S")
    if sim:
        for i in range(num_experiments):
            rospy.loginfo("STARTING EXPERIMENT " + str(i))

            for metric in sequencing_metrics:
                rospy.loginfo("METRIC: " + metric)
                still_running = True
                file_output = '{}_{}_{}_sim'.format(config_file_name, time_base, metric)

                import pdb

                planner = sawyer_planner_node.SawyerPlanner(metric, goals, sim=sim, starting_joints=starting_joints,
                                                            robot_name=robot_name, file_output=file_output)
                planner.refresh_octomap()
                while still_running and not rospy.is_shutdown():
                    still_running = planner.update()
                    rate.sleep()

                planner.clean()

    else:
        random.shuffle(sequencing_metrics)
        octomap_generated = False
        for metric in sequencing_metrics:

            if config_file_name is None:
                config_file_name = 'results'

            rospy.loginfo('METRIC: {}'.format(metric))
            file_output = '{}_{}_{}'.format(config_file_name, time_base, metric)
            planner = sawyer_planner_node.SawyerPlanner(metric, goals, sim=sim, robot_name=robot_name, file_output=file_output)
            if not octomap_generated:
                octomap_generated = True
                planner.refresh_octomap()
            if existing_config:
                planner.plan_to_joints(starting_joints)
                planner.initial_joints.position = starting_joints

            still_running = True

            try:
                while still_running and not rospy.is_shutdown():
                    # print(planner.goal_array)
                    # planner.sequence_goals()
                    still_running = planner.update()

                    rate.sleep()
            finally:
                planner.stop_arm()
                planner.go_to_start()
                planner.clean()
