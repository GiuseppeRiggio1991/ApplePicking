#!/usr/bin/env python

import rospy

from sawyer_planner import sawyer_planner_node
import sys
import random
import numpy
import numpy as np
import openravepy
import pyquaternion
import cPickle
import math
import rospkg
import os
from sensor_msgs.msg import JointState
from pprint import pprint

LOGGING = True
# sequencing_metrics = ['hybrid', 'euclidean', 'fredsmp']
# sequencing_metrics = ['fredsmp', 'euclidean']
#sequencing_metrics = ['euclidean']
sequencing_metrics = ['fredsmp']
num_targets = 5
num_experiments = 1

def transform_target_start(target, planner):
    q = pyquaternion.Quaternion(0.5, -0.5, 0.5, -0.5)
    goal_off = target - numpy.array([0.25, 0.0, 0.0])
    # compute camera transform
    T_EE = numpy.zeros((4, 4))
    T_EE[:3, :3] = q.rotation_matrix
    T_EE[:3, 3] = goal_off.transpose()
    T_EE[3, 3] = 1.0

    T_C = numpy.dot(T_EE, numpy.linalg.inv(planner.T_G2EE))
    return T_C

def transform_target_offset(target, planner):
    q = pyquaternion.Quaternion(0.5, -0.5, 0.5, -0.5)
    goal_off = target - numpy.array([planner.go_to_goal_offset, 0.0, 0.0])
    # compute camera transform
    T_EE = numpy.zeros((4, 4))
    T_EE[:3, :3] = q.rotation_matrix
    T_EE[:3, 3] = goal_off.transpose()
    T_EE[3, 3] = 1.0

    T_C = numpy.dot(T_EE, numpy.linalg.inv(planner.T_G2EE))
    return T_C

def gen_goal_and_noise_arrays(planner, num_targets=1):
    # random.seed(time.time())
    # numpy.random.seed(time.time())
    goal_array = []
    orientation_array = []
    noise_array = []
    solutions = []
    solutions_offset = []
    for i in range(num_targets):  # ensure target is reachable
        while len(solutions) == 0:
            # rand_x = random.uniform(0.65, 0.75)
            # rand_y = random.uniform(-0.35, 0.35)
            rand_x = random.uniform(0.2, 0.75)
            rand_y = 1.15-rand_x
            rand_z = random.uniform(0.2, 0.7)
            target = [rand_x, rand_y, rand_z]
            T_robot = transform_target_start(target, planner)
            pose_msg = planner.pose_to_ros_msg(openravepy.poseFromMatrix(T_robot))
            resp = planner.find_ik_solutions_srv(pose_msg, False)
            solutions = resp.solutions
            print len(solutions)
            # solutions = planner.ikmodel.manip.FindIKSolutions(
            #             T_robot,
            #             openravepy.IkFilterOptions.CheckEnvCollisions)
        goal_array.append(target)

        # Add the orientation reference in; tries to make branch "tangent" to robot arm

        goal = np.array(target)
        angle = math.atan2(goal[1], goal[0])
        r = np.sqrt(goal[0] ** 2 + goal[1] ** 2)
        rx, ry = r * math.cos(angle + 0.01), r * math.sin(angle + 0.01)  # Creates branch "tangent" to radius
        rz = goal[2]

        ref_point = np.array([rx, ry, rz])
        diff = ref_point - goal
        diff = diff / np.sqrt((diff ** 2).sum())
        # This is where the elevation difference comes in
        diff[2] = random.choice([0.5, 10, -0.5, -10])

        ref_point = goal + diff

        orientation_array.append(ref_point)

        while len(solutions_offset) == 0:  # ensure noisy target is reachable
            x_noise = numpy.random.normal(0.01, 0.01)
            y_noise = numpy.random.normal(0.0, 0.1)
            z_noise = numpy.random.normal(0.0, 0.1)
            noisy_target = numpy.asarray(goal_array[-1] + numpy.asarray([x_noise, y_noise, z_noise]))
            # print noisy_target
            T_robot_offset = transform_target_offset(noisy_target, planner)
            pose_msg = planner.pose_to_ros_msg(openravepy.poseFromMatrix(T_robot_offset))
            resp = planner.find_ik_solutions_srv(pose_msg, True)
            solutions_offset = resp.solutions
            print len(solutions_offset)
            # solutions_offset = planner.ikmodel.manip.FindIKSolutions(
            #             T_robot_offset,
            #             openravepy.IkFilterOptions.CheckEnvCollisions)
        noise_array.append([x_noise, y_noise, z_noise])
        solutions_offset = []
        solutions = []
    noise_array = numpy.asarray(noise_array)

    return goal_array, orientation_array, noise_array


if __name__ == "__main__":

    rospy.init_node('sawyer_planner')
    rate = rospy.Rate(1000)
    # sim = False
    # if len(sys.argv) > 1:
    #     if sys.argv[1] == 'sim':
    #         sim = True
    if rospy.has_param("sim"):
        sim = rospy.get_param("sim")
    else:
        sim = False

    existing_config = {}
    file_path = ''
    if len(sys.argv) > 1:
        config_file_name = sys.argv[1].strip()

        rospack = rospkg.RosPack()
        config_dir = os.path.join(rospack.get_path('sawyer_planner'), 'configs')
        if not os.path.exists(config_dir):
            os.makedirs(config_dir)
        try:
            file_path = os.path.join(config_dir, config_file_name)
            with open(file_path, 'rb') as fh:
                existing_config = cPickle.load(fh)
                rospy.loginfo('Found existing config {}'.format(config_file_name))
                pprint(existing_config)
        except IOError:
            if sim:
                raise ValueError('Could not find a "{}" config file, and running on sim!'.format(config_file_name))
            else:
                rospy.loginfo('Will create new config "{}" based on current arm configuration and goals'.format(config_file_name))

    goal_array = existing_config.get('goal', None)
    orientation_array = existing_config.get('orientation', None)
    noise_array = existing_config.get('noise', None)
    starting_joints = existing_config.get('starting_joints', None)


    USE_RGB_SEG = rospy.get_param('/use_camera', False) and rospy.get_param('/target_color', False)

    if rospy.has_param('/robot_name'):
        print "rospy.get_param: "
        print rospy.get_param("/robot_name")
        robot_name = rospy.get_param("/robot_name")
    else:
        print "no robot_name param, using sawyer "
        robot_name = "sawyer"

    still_running = True
    if sim:
        for i in range(num_experiments):
            rospy.loginfo("STARTING EXPERIMENT " + str(i))

            # Generate cut points, but only if we're not using a pre-existing configuration
            if not existing_config and not USE_RGB_SEG:
                planner = sawyer_planner_node.SawyerPlanner('euclidean', sim, robot_name=robot_name)
                goal_array, orientation_array, noise_array = gen_goal_and_noise_arrays(planner, num_targets)

            for metric in sequencing_metrics:
                rospy.loginfo("METRIC: " + metric)
                still_running = True
                planner = sawyer_planner_node.SawyerPlanner(metric, sim, goal_array, orientation_array, noise_array, starting_joints, robot_name=robot_name)
                while still_running and not rospy.is_shutdown():
                    still_running = planner.update()
                    rate.sleep()
        planner.go_to_start()

    else:
        metric = sequencing_metrics[0]

        planner = sawyer_planner_node.SawyerPlanner(metric, sim, goal_array, orientation_array, noise_array, robot_name=robot_name)
        if not existing_config and file_path:
            planner.rgb_segment_set_goal()
            config_to_save = {}
            config_to_save['goal'] = planner.goal_array
            config_to_save['noise'] = planner.noise_array
            config_to_save['orientation'] = planner.orientation_array
            config_to_save['starting_joints'] = rospy.wait_for_message('manipulator_joints', JointState).position
            with open(file_path, 'wb') as fh:
                cPickle.dump(config_to_save, fh)
            rospy.loginfo('Saved start config {}'.format(config_file_name))
            pprint(config_to_save)

        if existing_config:
            planner.plan_to_joints(starting_joints)
            planner.initial_joints.position = starting_joints

        try:
            while still_running and not rospy.is_shutdown():
                # print(planner.goal_array)
                # planner.sequence_goals()
                still_running = planner.update()

                rate.sleep()
        finally:
            planner.stop_arm()
            planner.go_to_start()


    rospy.on_shutdown(planner.clean)
